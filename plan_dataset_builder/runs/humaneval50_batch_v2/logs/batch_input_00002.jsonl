{"custom_id": "humaneval50_batch_v2:humaneval:HumanEval/102:b2:a1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1-mini", "input": "You are generating planning-only artifacts for benchmark task analysis.\n\nReturn ONLY valid JSON (no markdown, no prose), as a JSON array of exactly 4 plan objects.\n\nTask metadata:\n- dataset: humaneval\n- task_id: HumanEval/102\n- batch_number: 2\n- schema_version: 1.0\n\nAllowed strategy labels for this call (use exactly one per plan, and each of the 4 plans must use a different label from this set):\n[\"Pseudocode-First\", \"Decompose-Then-Solve\", \"Brute-Force-Then-Optimize\", \"Type-Driven\"]\n\nStructural bounds:\n{\"max_depth\": 2, \"max_total_steps\": 25, \"min_steps\": 4}\n\nHard requirements:\n1) Output a JSON array of length 4.\n2) Each plan object must contain:\n   - schema_version (must equal \"1.0\")\n   - strategy_label (must be one of the allowed labels above)\n   - unique_step (non-empty, and different across the 4 plans)\n   - steps (list with at least 4 top-level step objects)\n3) Each step object must contain:\n   - id (e.g. \"1\", \"2\", \"2.1\")\n   - action (imperative, non-empty)\n   - rationale (non-empty)\n   - optional checks: list[string]\n   - optional substeps: list[step]\n4) Avoid placeholders like TBD/TODO/fill in/unknown.\n5) Respect the max depth and max total step bounds.\n\nTask:\n[DATASET] humaneval\n[TASK_ID] HumanEval/102\n\n[PRIMARY_TASK]\n\ndef choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n\n\n[CONTEXT_FIELDS]\nentry_point:\nchoose_num\n\ntask_id:\nHumanEval/102\n\n", "temperature": 0.2, "top_p": 1.0, "max_output_tokens": 2500, "text": {"format": {"type": "json_schema", "name": "plan_group", "schema": {"type": "object", "additionalProperties": false, "required": ["plans"], "properties": {"plans": {"type": "array", "minItems": 4, "maxItems": 4, "items": {"type": "object", "additionalProperties": false, "required": ["schema_version", "strategy_label", "unique_step", "steps"], "properties": {"schema_version": {"type": "string", "const": "1.0"}, "strategy_label": {"type": "string"}, "unique_step": {"type": "string", "minLength": 1}, "steps": {"type": "array", "items": {"$ref": "#/$defs/step"}, "minItems": 1}}}}}, "$defs": {"step": {"type": "object", "additionalProperties": false, "required": ["id", "action", "rationale", "checks", "substeps"], "properties": {"id": {"type": "string", "minLength": 1}, "action": {"type": "string", "minLength": 1}, "rationale": {"type": "string", "minLength": 1}, "checks": {"anyOf": [{"type": "array", "items": {"type": "string"}}, {"type": "null"}]}, "substeps": {"anyOf": [{"type": "array", "items": {"$ref": "#/$defs/step"}}, {"type": "null"}]}}}}}, "strict": true}}}}
{"custom_id": "humaneval50_batch_v2:humaneval:HumanEval/112:b2:a1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1-mini", "input": "You are generating planning-only artifacts for benchmark task analysis.\n\nReturn ONLY valid JSON (no markdown, no prose), as a JSON array of exactly 4 plan objects.\n\nTask metadata:\n- dataset: humaneval\n- task_id: HumanEval/112\n- batch_number: 2\n- schema_version: 1.0\n\nAllowed strategy labels for this call (use exactly one per plan, and each of the 4 plans must use a different label from this set):\n[\"Pseudocode-First\", \"Decompose-Then-Solve\", \"Brute-Force-Then-Optimize\", \"Type-Driven\"]\n\nStructural bounds:\n{\"max_depth\": 2, \"max_total_steps\": 25, \"min_steps\": 4}\n\nHard requirements:\n1) Output a JSON array of length 4.\n2) Each plan object must contain:\n   - schema_version (must equal \"1.0\")\n   - strategy_label (must be one of the allowed labels above)\n   - unique_step (non-empty, and different across the 4 plans)\n   - steps (list with at least 4 top-level step objects)\n3) Each step object must contain:\n   - id (e.g. \"1\", \"2\", \"2.1\")\n   - action (imperative, non-empty)\n   - rationale (non-empty)\n   - optional checks: list[string]\n   - optional substeps: list[step]\n4) Avoid placeholders like TBD/TODO/fill in/unknown.\n5) Respect the max depth and max total step bounds.\n\nTask:\n[DATASET] humaneval\n[TASK_ID] HumanEval/112\n\n[PRIMARY_TASK]\n\ndef reverse_delete(s,c):\n    \"\"\"Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n    \"\"\"\n\n\n[CONTEXT_FIELDS]\nentry_point:\nreverse_delete\n\ntask_id:\nHumanEval/112\n\n", "temperature": 0.2, "top_p": 1.0, "max_output_tokens": 2500, "text": {"format": {"type": "json_schema", "name": "plan_group", "schema": {"type": "object", "additionalProperties": false, "required": ["plans"], "properties": {"plans": {"type": "array", "minItems": 4, "maxItems": 4, "items": {"type": "object", "additionalProperties": false, "required": ["schema_version", "strategy_label", "unique_step", "steps"], "properties": {"schema_version": {"type": "string", "const": "1.0"}, "strategy_label": {"type": "string"}, "unique_step": {"type": "string", "minLength": 1}, "steps": {"type": "array", "items": {"$ref": "#/$defs/step"}, "minItems": 1}}}}}, "$defs": {"step": {"type": "object", "additionalProperties": false, "required": ["id", "action", "rationale", "checks", "substeps"], "properties": {"id": {"type": "string", "minLength": 1}, "action": {"type": "string", "minLength": 1}, "rationale": {"type": "string", "minLength": 1}, "checks": {"anyOf": [{"type": "array", "items": {"type": "string"}}, {"type": "null"}]}, "substeps": {"anyOf": [{"type": "array", "items": {"$ref": "#/$defs/step"}}, {"type": "null"}]}}}}}, "strict": true}}}}
{"custom_id": "humaneval50_batch_v2:humaneval:HumanEval/117:b2:a1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1-mini", "input": "You are generating planning-only artifacts for benchmark task analysis.\n\nReturn ONLY valid JSON (no markdown, no prose), as a JSON array of exactly 4 plan objects.\n\nTask metadata:\n- dataset: humaneval\n- task_id: HumanEval/117\n- batch_number: 2\n- schema_version: 1.0\n\nAllowed strategy labels for this call (use exactly one per plan, and each of the 4 plans must use a different label from this set):\n[\"Pseudocode-First\", \"Decompose-Then-Solve\", \"Brute-Force-Then-Optimize\", \"Type-Driven\"]\n\nStructural bounds:\n{\"max_depth\": 2, \"max_total_steps\": 25, \"min_steps\": 4}\n\nHard requirements:\n1) Output a JSON array of length 4.\n2) Each plan object must contain:\n   - schema_version (must equal \"1.0\")\n   - strategy_label (must be one of the allowed labels above)\n   - unique_step (non-empty, and different across the 4 plans)\n   - steps (list with at least 4 top-level step objects)\n3) Each step object must contain:\n   - id (e.g. \"1\", \"2\", \"2.1\")\n   - action (imperative, non-empty)\n   - rationale (non-empty)\n   - optional checks: list[string]\n   - optional substeps: list[step]\n4) Avoid placeholders like TBD/TODO/fill in/unknown.\n5) Respect the max depth and max total step bounds.\n\nTask:\n[DATASET] humaneval\n[TASK_ID] HumanEval/117\n\n[PRIMARY_TASK]\n\ndef select_words(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n\n\n[CONTEXT_FIELDS]\nentry_point:\nselect_words\n\ntask_id:\nHumanEval/117\n\n", "temperature": 0.2, "top_p": 1.0, "max_output_tokens": 2500, "text": {"format": {"type": "json_schema", "name": "plan_group", "schema": {"type": "object", "additionalProperties": false, "required": ["plans"], "properties": {"plans": {"type": "array", "minItems": 4, "maxItems": 4, "items": {"type": "object", "additionalProperties": false, "required": ["schema_version", "strategy_label", "unique_step", "steps"], "properties": {"schema_version": {"type": "string", "const": "1.0"}, "strategy_label": {"type": "string"}, "unique_step": {"type": "string", "minLength": 1}, "steps": {"type": "array", "items": {"$ref": "#/$defs/step"}, "minItems": 1}}}}}, "$defs": {"step": {"type": "object", "additionalProperties": false, "required": ["id", "action", "rationale", "checks", "substeps"], "properties": {"id": {"type": "string", "minLength": 1}, "action": {"type": "string", "minLength": 1}, "rationale": {"type": "string", "minLength": 1}, "checks": {"anyOf": [{"type": "array", "items": {"type": "string"}}, {"type": "null"}]}, "substeps": {"anyOf": [{"type": "array", "items": {"$ref": "#/$defs/step"}}, {"type": "null"}]}}}}}, "strict": true}}}}
{"custom_id": "humaneval50_batch_v2:humaneval:HumanEval/124:b1:a1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1-mini", "input": "You are generating planning-only artifacts for benchmark task analysis.\n\nReturn ONLY valid JSON (no markdown, no prose), as a JSON array of exactly 4 plan objects.\n\nTask metadata:\n- dataset: humaneval\n- task_id: HumanEval/124\n- batch_number: 1\n- schema_version: 1.0\n\nAllowed strategy labels for this call (use exactly one per plan, and each of the 4 plans must use a different label from this set):\n[\"Pseudocode-First\", \"Decompose-Then-Solve\", \"Brute-Force-Then-Optimize\", \"Type-Driven\"]\n\nStructural bounds:\n{\"max_depth\": 2, \"max_total_steps\": 25, \"min_steps\": 4}\n\nHard requirements:\n1) Output a JSON array of length 4.\n2) Each plan object must contain:\n   - schema_version (must equal \"1.0\")\n   - strategy_label (must be one of the allowed labels above)\n   - unique_step (non-empty, and different across the 4 plans)\n   - steps (list with at least 4 top-level step objects)\n3) Each step object must contain:\n   - id (e.g. \"1\", \"2\", \"2.1\")\n   - action (imperative, non-empty)\n   - rationale (non-empty)\n   - optional checks: list[string]\n   - optional substeps: list[step]\n4) Avoid placeholders like TBD/TODO/fill in/unknown.\n5) Respect the max depth and max total step bounds.\n\nTask:\n[DATASET] humaneval\n[TASK_ID] HumanEval/124\n\n[PRIMARY_TASK]\n\ndef valid_date(date):\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"\n\n\n[CONTEXT_FIELDS]\nentry_point:\nvalid_date\n\ntask_id:\nHumanEval/124\n\n", "temperature": 0.2, "top_p": 1.0, "max_output_tokens": 2500, "text": {"format": {"type": "json_schema", "name": "plan_group", "schema": {"type": "object", "additionalProperties": false, "required": ["plans"], "properties": {"plans": {"type": "array", "minItems": 4, "maxItems": 4, "items": {"type": "object", "additionalProperties": false, "required": ["schema_version", "strategy_label", "unique_step", "steps"], "properties": {"schema_version": {"type": "string", "const": "1.0"}, "strategy_label": {"type": "string"}, "unique_step": {"type": "string", "minLength": 1}, "steps": {"type": "array", "items": {"$ref": "#/$defs/step"}, "minItems": 1}}}}}, "$defs": {"step": {"type": "object", "additionalProperties": false, "required": ["id", "action", "rationale", "checks", "substeps"], "properties": {"id": {"type": "string", "minLength": 1}, "action": {"type": "string", "minLength": 1}, "rationale": {"type": "string", "minLength": 1}, "checks": {"anyOf": [{"type": "array", "items": {"type": "string"}}, {"type": "null"}]}, "substeps": {"anyOf": [{"type": "array", "items": {"$ref": "#/$defs/step"}}, {"type": "null"}]}}}}}, "strict": true}}}}
{"custom_id": "humaneval50_batch_v2:humaneval:HumanEval/136:b3:a1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1-mini", "input": "You are generating planning-only artifacts for benchmark task analysis.\n\nReturn ONLY valid JSON (no markdown, no prose), as a JSON array of exactly 4 plan objects.\n\nTask metadata:\n- dataset: humaneval\n- task_id: HumanEval/136\n- batch_number: 3\n- schema_version: 1.0\n\nAllowed strategy labels for this call (use exactly one per plan, and each of the 4 plans must use a different label from this set):\n[\"Invariants-First\", \"Pseudocode-First\", \"Decompose-Then-Solve\", \"Brute-Force-Then-Optimize\"]\n\nStructural bounds:\n{\"max_depth\": 2, \"max_total_steps\": 25, \"min_steps\": 4}\n\nHard requirements:\n1) Output a JSON array of length 4.\n2) Each plan object must contain:\n   - schema_version (must equal \"1.0\")\n   - strategy_label (must be one of the allowed labels above)\n   - unique_step (non-empty, and different across the 4 plans)\n   - steps (list with at least 4 top-level step objects)\n3) Each step object must contain:\n   - id (e.g. \"1\", \"2\", \"2.1\")\n   - action (imperative, non-empty)\n   - rationale (non-empty)\n   - optional checks: list[string]\n   - optional substeps: list[step]\n4) Avoid placeholders like TBD/TODO/fill in/unknown.\n5) Respect the max depth and max total step bounds.\n\nTask:\n[DATASET] humaneval\n[TASK_ID] HumanEval/136\n\n[PRIMARY_TASK]\n\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n\n\n[CONTEXT_FIELDS]\nentry_point:\nlargest_smallest_integers\n\ntask_id:\nHumanEval/136\n\n", "temperature": 0.2, "top_p": 1.0, "max_output_tokens": 2500, "text": {"format": {"type": "json_schema", "name": "plan_group", "schema": {"type": "object", "additionalProperties": false, "required": ["plans"], "properties": {"plans": {"type": "array", "minItems": 4, "maxItems": 4, "items": {"type": "object", "additionalProperties": false, "required": ["schema_version", "strategy_label", "unique_step", "steps"], "properties": {"schema_version": {"type": "string", "const": "1.0"}, "strategy_label": {"type": "string"}, "unique_step": {"type": "string", "minLength": 1}, "steps": {"type": "array", "items": {"$ref": "#/$defs/step"}, "minItems": 1}}}}}, "$defs": {"step": {"type": "object", "additionalProperties": false, "required": ["id", "action", "rationale", "checks", "substeps"], "properties": {"id": {"type": "string", "minLength": 1}, "action": {"type": "string", "minLength": 1}, "rationale": {"type": "string", "minLength": 1}, "checks": {"anyOf": [{"type": "array", "items": {"type": "string"}}, {"type": "null"}]}, "substeps": {"anyOf": [{"type": "array", "items": {"$ref": "#/$defs/step"}}, {"type": "null"}]}}}}}, "strict": true}}}}
